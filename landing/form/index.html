#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Extrae jerarquía MARCA (C1) -> MODELO (C2) -> VERSIONES (resto) desde Autos.pdf
- Lee todas las tablas con Tabula (lattice + stream)
- Propaga Marca y Modelo por bloque
- Conserva las versiones tal cual aparecen (sin deduplicar)
- Detecta años (2011..2025) por versión si están en la fila
Salida:
  autos_full.json           {Marca: {Modelo: [Versiones...]}}
  autos_full_years.json     {Marca: {Modelo: {Versión: [Años...]}}}
"""

import re, json
from collections import defaultdict
import pandas as pd
import tabula

PDF = "Autos.pdf"
OUT1 = "autos_full.json"
OUT2 = "autos_full_years.json"

YEAR_MIN, YEAR_MAX = 2011, 2025
YEAR_RE = re.compile(r"\b(20[1-2]\d)\b")

# Filas que conviene ignorar
SKIP_PATTERNS = [
    r"Autos - Pick Ups - Todo Terreno - Utilitarios",
    r"Visite Nuestro Sitio",
    r"0\s*Km .*2011",
    r"EN US\$",
    r"Noviembre 20\d{2}",
    r"0KM EN US\$",
    r"Catálogo|Página \d+ de \d+",
]

def skip_text(s: str) -> bool:
    s = (s or "").strip()
    if not s:
        return True
    for p in SKIP_PATTERNS:
        if re.search(p, s, re.IGNORECASE):
            return True
    return False

def norm(s: str) -> str:
    return re.sub(r"\s+", " ", (s or "").strip())

def is_model_header(txt: str) -> bool:
    """Modelo (columna 2) suele ser corto, sin comas, ni specs; 1-3 tokens, letras/números."""
    if not txt: return False
    if "," in txt: return False
    tokens = txt.split()
    return 1 <= len(tokens) <= 3 and all(re.match(r"^[A-Za-z0-9\-\+\/]+$", t) for t in tokens)

def main():
    # Leemos con lattice y stream para cubrir todos los layouts
    frames = []
    for mode in ("lattice", "stream"):
        try:
            dfs = tabula.read_pdf(PDF, pages="all", multiple_tables=True, **{mode: True})
            for df in dfs or []:
                if isinstance(df, pd.DataFrame) and df.shape[0] > 0:
                    frames.append(df)
        except Exception:
            pass
    if not frames:
        raise SystemExit("No se detectaron tablas. Probá instalar Java o compartir otra muestra.")

    # Unificamos filas normalizadas
    rows = []
    for df in frames:
        df = df.copy()
        df.columns = [f"C{i+1}" for i in range(df.shape[1])]
        for _, r in df.iterrows():
            vals = [norm(r.get(c, "")) for c in df.columns]
            # si TODAS las celdas están vacías/ruido, salteamos
            if all(skip_text(v) for v in vals):
                continue
            rows.append(vals)

    # Armamos estructura jerárquica
    autos = defaultdict(lambda: defaultdict(list))                    # Marca -> Modelo -> [Versiones]
    autos_years = defaultdict(lambda: defaultdict(lambda: defaultdict(set)))
    current_brand = None
    current_model = None

    for vals in rows:
        c1 = vals[0] if len(vals) > 0 else ""
        c2 = vals[1] if len(vals) > 1 else ""
        tail = vals[2:] if len(vals) > 2 else []

        # ¿Es fila de MARCA? (solo C1 con texto útil, C2 vacío o encabezado)
        if c1 and not skip_text(c1) and (not c2 or re.fullmatch(r"(?i)(modelo|versi[oó]n.*|detalle.*)", c2 or "")):
            current_brand = c1.title()
            current_model = None
            continue

        # Si hay MARCA vigente, evaluamos MODELO y VERSIONES
        if current_brand:
            # ¿Es MODELO en C2?
            if c2 and is_model_header(c2):
                current_model = c2.upper()  # en muchos catálogos está en mayúsculas
                continue

            # Si ya tenemos marca y modelo, esta fila es una VERSIÓN (unimos C2 + resto)
            if current_model:
                raw = " ".join([c for c in [c2] + tail if c]).strip()
                if not raw:
                    continue
                version = raw  # conservar tal cual
                autos[current_brand][current_model].append(version)

                # años si están
                joined = " ".join(vals)
                for y in YEAR_RE.findall(joined):
                    y = int(y)
                    if YEAR_MIN <= y <= YEAR_MAX:
                        autos_years[current_brand][current_model][version].add(y)

    # Serializar
    out1 = {b: {m: list(vs) for m, vs in models.items()} for b, models in autos.items()}
    out2 = {
        b: {m: {v: sorted(list(ys)) for v, ys in vers.items()} for m, vers in models.items()}
        for b, models in autos_years.items()
    }
    with open(OUT1, "w", encoding="utf-8") as f:
        json.dump(out1, f, ensure_ascii=False, indent=2)
    with open(OUT2, "w", encoding="utf-8") as f:
        json.dump(out2, f, ensure_ascii=False, indent=2)
    print(f"Listo -> {OUT1}, {OUT2}")

if __name__ == "__main__":
    main()
